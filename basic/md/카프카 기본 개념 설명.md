- [카프카 기본 개념 설명](#카프카-기본-개념-설명)
  - [오픈소스 아파치 카프카 생태계](#오픈소스-아파치-카프카-생태계)
  - [카프카 브로커와 클러스터](#카프카-브로커와-클러스터)
  - [카프카 클러스터와 주키퍼](#카프카-클러스터와-주키퍼)
  - [카프카 브로커의 역할들](#카프카-브로커의-역할들)
  - [브로커 로그와 세그먼트](#브로커-로그와-세그먼트)
  - [세그먼트와 삭제 주기(cleanup.policy)](#세그먼트와-삭제-주기cleanuppolicy)
  - [복제(replication)](#복제replication)
  - [ISR(In-Sync-Replicas)](#isrin-sync-replicas)
  - [토픽과 파티션](#토픽과-파티션)
  - [레코드](#레코드)
  - [유지보수하기 좋은 토픽 이름 정하기](#유지보수하기-좋은-토픽-이름-정하기)
  - [클라이언트 메타데이터와 브로커 통신](#클라이언트-메타데이터와-브로커-통신)
  - [퀴즈](#퀴즈)

---

# 카프카 기본 개념 설명

## 오픈소스 아파치 카프카 생태계

![아파치 카프카 생태계](/images/2022-06-07-00-22-09.png)

- 토픽은 목적에 따라서 생성이 됨
- 기본적으로 데이터를 넣는 역할을 하는 것이 프로듀서
- 프로듀서가 넣은 데이터는 토픽에 데이터가 들어가게 되고, 이 토픽에 담긴 데이터를 가져가는 것이 컨슈머이다.
- 이 토픽에 저장된 데이터를 stateless, stateful 하게 데이터를 처리하고 싶다면 카프카 스트림즈라는 라이브러를 쓰면 됩니다.
- 커넥트(소스, 싱크), 스트림즈는 모두 아파치 카프카에 포함된 것입니다.
- 오픈소스 카프카에 포함된 내용들은 아파치 카프카에 기본적으로 릴리즈가 되어 있습니다. (Java로 기본적으로 제공, 공식)
- 3rd party 라이브러리 같은 경우에는 카프카에서 제공하는 기능들을 완벽히 쓰고 있다고 보장이 되지 않는다. (go, js 등으로 제공)
- 커넥트는 데이터 파이프라인을 해결하는 가장 핵심적인 툴
  - 소스 커넥터 : 프로듀서 역할, 특정 데이터 베이스나 소스 애플리케이션으로부터 데이터를 가져와서 토픽에 데이터를 넣는 역할
  - 싱크 커넥터 : 컨슈머 역할, 타겟 애플리케이션으로 보내는 역할
  - 템플릿 형태로 반복적으로 여러번 생성할 수 있음(프로듀서와 컨슈머로 구현해도 되지 않느냐? 라고 할 수 있는데 그에 대한 반박이 될 것)

cf.) Mirror maker2 : 클러스터 단위로 카프카를 운영할 때 토픽에 있는 데이터를 완벽하게 복제할 때 사용하는 것

## 카프카 브로커와 클러스터

![](/images/2022-06-07-01-30-08.png)

- 카프카 브로커는 카프카 클라이언트와 데이터를 주고 받기 위해 사용하는 주체이자, 데이터를 분산 저장하여 장애가 발생하더라도 안전하게 사용할 수 있도록 도와주는 애플리케이션.
- 카프카 2.x 버전까지는 반드시 주키퍼가 필요하고, 3.x 버전부터는 주키퍼가 필요하진 않아도 되는데, 아직까진 완벽하게 주키퍼를 대체하지 못하는 경우가 있기 때문에 아직까지는 주키퍼가 있는 카프카 클러스터를 운영하고 있다.
- 한개의 카프카 클러스터는 여러개의 브로커로 구성되어 있다.
  - 한개의 브로커는 하나의 물리 서버나, 서버, 인스턴스에서 동작하게 된다.
- 하나의 서버에는 한 개의 브로커 프로세스가 실행된다.
- 카프카 브로커 서버 1대로도 기본 기능이 실행되지만, 데이터를 안전하게 보관하고 처리하기 위해 3대 이상의 브로커 서버를 1개의 클러스터로 묶어서 운영한다.
- 카프카 클러스터로 묶은 브로커들은 프로듀서가 보낸 데이터를 안전하게 분산 저장하고 복제하는 역할을 수행한다.
- 하나의 브로커에 장애가 발생하더라도, 다른 브로커에 데이터가 복제가 되어 있으면 장애 대응에 유리하기에 데이터를 복제, 분산 저장할 때 안전한 운영을 위해 여러개의 브로커가 존재한다고 이해하면 된다.

## 카프카 클러스터와 주키퍼

![](/images/2022-06-07-01-35-38.png)

- 카프카 클러스터를 여러대로 운영하는 경우도 많습니다.
- 카프카 클러스터를 실행하기 위해서는 **주키퍼**가 필요.
- 주키퍼의 서로 다른 znode에 클러스터를 지정하면 됨
- **root znode에 각 클러스터별 znode를 생성하고, 클러스터 실행시 root가 아닌 하위 znode로 설정**
  - 고객팀, 결제팀, 주문팀이 따로 카프카 클러스터를 운영해도 주키퍼를 하나의 앙상블로 운영할 때 동시에 운영할 수 있다.
- 주키퍼의 영향도를 줄이기 위해 하나의 클러스터에 대해 주키퍼를 각각 다르게 가져갈 수도 있긴 하지만, 리소스가 많이 발생할 수 있기 때문에 위와 같이 하나의 앙상블로 관리하기도 한다.
- 주키퍼가 반드시 필요하기 때문에 위와 같이 형태를 고려했었는데 카프카 3.0 부터는 주키퍼가 없어도 클러스터 동작 가능.(아직까지는 상용에 주키퍼 없이 운영했다는 보고가 없지만, 가까운 미래에는 될 것)

## 카프카 브로커의 역할들

## 브로커 로그와 세그먼트

## 세그먼트와 삭제 주기(cleanup.policy)

## 복제(replication)

## ISR(In-Sync-Replicas)

## 토픽과 파티션

## 레코드

## 유지보수하기 좋은 토픽 이름 정하기

## 클라이언트 메타데이터와 브로커 통신

## 퀴즈


> 정답